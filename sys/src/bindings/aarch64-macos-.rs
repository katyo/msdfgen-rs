/* automatically generated by rust-bindgen 0.60.1 */

pub const MSDFGEN_CUBIC_SEARCH_STARTS: u32 = 4;
pub const MSDFGEN_CUBIC_SEARCH_STEPS: u32 = 4;
pub const MSDFGEN_CORNER_DOT_EPSILON: f64 = 0.000001;
pub const MSDFGEN_DECONVERGENCE_FACTOR: f64 = 0.000001;
pub const MSDFGEN_EDGE_LENGTH_PRECISION: u32 = 4;
pub const MSDFGEN_VERSION: &[u8; 4usize] = b"1.9\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = u64;
pub type std_allocator_difference_type = u64;
pub type std_allocator_value_type = u8;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
pub type std_allocator_pointer = u8;
pub type std_allocator_const_pointer = u8;
pub type std_allocator_reference = u8;
pub type std_allocator_const_reference = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector___base = u8;
pub type std_vector___default_allocator_type = u8;
pub type std_vector___self = u8;
pub type std_vector_value_type = u8;
pub type std_vector_allocator_type = u8;
pub type std_vector___alloc_traits = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_size_type = u8;
pub type std_vector_difference_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__ConstructTransaction {
    pub _address: u8,
}
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __darwin_off_t = __int64_t;
#[doc = " A 2-dimensional euclidean vector with double precision."]
#[doc = " Implementation based on the Vector2 template from Artery Engine."]
#[doc = " @author Viktor Chlumsky"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_Vector2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_msdfgen_Vector2() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_Vector2>(),
        16usize,
        concat!("Size of: ", stringify!(msdfgen_Vector2))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_Vector2>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_Vector2))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Vector2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Vector2),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Vector2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Vector2),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
extern "C" {
    #[doc = " Sets the vector to zero."]
    #[link_name = "\u{1}__ZN7msdfgen7Vector25resetEv"]
    pub fn msdfgen_Vector2_reset(this: *mut msdfgen_Vector2);
}
extern "C" {
    #[doc = " Sets individual elements of the vector."]
    #[link_name = "\u{1}__ZN7msdfgen7Vector23setEdd"]
    pub fn msdfgen_Vector2_set(this: *mut msdfgen_Vector2, x: f64, y: f64);
}
extern "C" {
    #[doc = " Returns the vector's length."]
    #[link_name = "\u{1}__ZNK7msdfgen7Vector26lengthEv"]
    pub fn msdfgen_Vector2_length(this: *const msdfgen_Vector2) -> f64;
}
extern "C" {
    #[doc = " Returns the angle of the vector in radians (atan2)."]
    #[link_name = "\u{1}__ZNK7msdfgen7Vector29directionEv"]
    pub fn msdfgen_Vector2_direction(this: *const msdfgen_Vector2) -> f64;
}
extern "C" {
    #[doc = " Returns the normalized vector - one that has the same direction but unit length."]
    #[link_name = "\u{1}__ZNK7msdfgen7Vector29normalizeEb"]
    pub fn msdfgen_Vector2_normalize(
        this: *const msdfgen_Vector2,
        allowZero: bool,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[doc = " Returns a vector with the same length that is orthogonal to this one."]
    #[link_name = "\u{1}__ZNK7msdfgen7Vector213getOrthogonalEb"]
    pub fn msdfgen_Vector2_getOrthogonal(
        this: *const msdfgen_Vector2,
        polarity: bool,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[doc = " Returns a vector with unit length that is orthogonal to this one."]
    #[link_name = "\u{1}__ZNK7msdfgen7Vector214getOrthonormalEbb"]
    pub fn msdfgen_Vector2_getOrthonormal(
        this: *const msdfgen_Vector2,
        polarity: bool,
        allowZero: bool,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[doc = " Returns a vector projected along this one."]
    #[link_name = "\u{1}__ZNK7msdfgen7Vector27projectERKS0_b"]
    pub fn msdfgen_Vector2_project(
        this: *const msdfgen_Vector2,
        vector: *const msdfgen_Vector2,
        positive: bool,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7Vector2C1Ed"]
    pub fn msdfgen_Vector2_Vector2(this: *mut msdfgen_Vector2, val: f64);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7Vector2C1Edd"]
    pub fn msdfgen_Vector2_Vector21(this: *mut msdfgen_Vector2, x: f64, y: f64);
}
impl msdfgen_Vector2 {
    #[inline]
    pub unsafe fn reset(&mut self) {
        msdfgen_Vector2_reset(self)
    }
    #[inline]
    pub unsafe fn set(&mut self, x: f64, y: f64) {
        msdfgen_Vector2_set(self, x, y)
    }
    #[inline]
    pub unsafe fn length(&self) -> f64 {
        msdfgen_Vector2_length(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> f64 {
        msdfgen_Vector2_direction(self)
    }
    #[inline]
    pub unsafe fn normalize(&self, allowZero: bool) -> msdfgen_Vector2 {
        msdfgen_Vector2_normalize(self, allowZero)
    }
    #[inline]
    pub unsafe fn getOrthogonal(&self, polarity: bool) -> msdfgen_Vector2 {
        msdfgen_Vector2_getOrthogonal(self, polarity)
    }
    #[inline]
    pub unsafe fn getOrthonormal(&self, polarity: bool, allowZero: bool) -> msdfgen_Vector2 {
        msdfgen_Vector2_getOrthonormal(self, polarity, allowZero)
    }
    #[inline]
    pub unsafe fn project(
        &self,
        vector: *const msdfgen_Vector2,
        positive: bool,
    ) -> msdfgen_Vector2 {
        msdfgen_Vector2_project(self, vector, positive)
    }
    #[inline]
    pub unsafe fn new(val: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_Vector2_Vector2(__bindgen_tmp.as_mut_ptr(), val);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(x: f64, y: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_Vector2_Vector21(__bindgen_tmp.as_mut_ptr(), x, y);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A 2-dimensional euclidean vector with double precision."]
#[doc = " Implementation based on the Vector2 template from Artery Engine."]
#[doc = " @author Viktor Chlumsky"]
pub type msdfgen_Point2 = msdfgen_Vector2;
#[doc = " A transformation from shape coordinates to pixel coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_Projection {
    pub scale: msdfgen_Vector2,
    pub translate: msdfgen_Vector2,
}
#[test]
fn bindgen_test_layout_msdfgen_Projection() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_Projection>(),
        32usize,
        concat!("Size of: ", stringify!(msdfgen_Projection))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_Projection>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_Projection))
    );
    fn test_field_scale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Projection>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Projection),
                "::",
                stringify!(scale)
            )
        );
    }
    test_field_scale();
    fn test_field_translate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Projection>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).translate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Projection),
                "::",
                stringify!(translate)
            )
        );
    }
    test_field_translate();
}
extern "C" {
    #[doc = " Converts the shape coordinate to pixel coordinate."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection7projectERKNS_7Vector2E"]
    pub fn msdfgen_Projection_project(
        this: *const msdfgen_Projection,
        coord: *const msdfgen_Point2,
    ) -> msdfgen_Point2;
}
extern "C" {
    #[doc = " Converts the pixel coordinate to shape coordinate."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection9unprojectERKNS_7Vector2E"]
    pub fn msdfgen_Projection_unproject(
        this: *const msdfgen_Projection,
        coord: *const msdfgen_Point2,
    ) -> msdfgen_Point2;
}
extern "C" {
    #[doc = " Converts the vector to pixel coordinate space."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection13projectVectorERKNS_7Vector2E"]
    pub fn msdfgen_Projection_projectVector(
        this: *const msdfgen_Projection,
        vector: *const msdfgen_Vector2,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[doc = " Converts the vector from pixel coordinate space."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection15unprojectVectorERKNS_7Vector2E"]
    pub fn msdfgen_Projection_unprojectVector(
        this: *const msdfgen_Projection,
        vector: *const msdfgen_Vector2,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[doc = " Converts the X-coordinate from shape to pixel coordinate space."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection8projectXEd"]
    pub fn msdfgen_Projection_projectX(this: *const msdfgen_Projection, x: f64) -> f64;
}
extern "C" {
    #[doc = " Converts the Y-coordinate from shape to pixel coordinate space."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection8projectYEd"]
    pub fn msdfgen_Projection_projectY(this: *const msdfgen_Projection, y: f64) -> f64;
}
extern "C" {
    #[doc = " Converts the X-coordinate from pixel to shape coordinate space."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection10unprojectXEd"]
    pub fn msdfgen_Projection_unprojectX(this: *const msdfgen_Projection, x: f64) -> f64;
}
extern "C" {
    #[doc = " Converts the Y-coordinate from pixel to shape coordinate space."]
    #[link_name = "\u{1}__ZNK7msdfgen10Projection10unprojectYEd"]
    pub fn msdfgen_Projection_unprojectY(this: *const msdfgen_Projection, y: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10ProjectionC1Ev"]
    pub fn msdfgen_Projection_Projection(this: *mut msdfgen_Projection);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10ProjectionC1ERKNS_7Vector2ES3_"]
    pub fn msdfgen_Projection_Projection1(
        this: *mut msdfgen_Projection,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
    );
}
impl msdfgen_Projection {
    #[inline]
    pub unsafe fn project(&self, coord: *const msdfgen_Point2) -> msdfgen_Point2 {
        msdfgen_Projection_project(self, coord)
    }
    #[inline]
    pub unsafe fn unproject(&self, coord: *const msdfgen_Point2) -> msdfgen_Point2 {
        msdfgen_Projection_unproject(self, coord)
    }
    #[inline]
    pub unsafe fn projectVector(&self, vector: *const msdfgen_Vector2) -> msdfgen_Vector2 {
        msdfgen_Projection_projectVector(self, vector)
    }
    #[inline]
    pub unsafe fn unprojectVector(&self, vector: *const msdfgen_Vector2) -> msdfgen_Vector2 {
        msdfgen_Projection_unprojectVector(self, vector)
    }
    #[inline]
    pub unsafe fn projectX(&self, x: f64) -> f64 {
        msdfgen_Projection_projectX(self, x)
    }
    #[inline]
    pub unsafe fn projectY(&self, y: f64) -> f64 {
        msdfgen_Projection_projectY(self, y)
    }
    #[inline]
    pub unsafe fn unprojectX(&self, x: f64) -> f64 {
        msdfgen_Projection_unprojectX(self, x)
    }
    #[inline]
    pub unsafe fn unprojectY(&self, y: f64) -> f64 {
        msdfgen_Projection_unprojectY(self, y)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_Projection_Projection(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(scale: *const msdfgen_Vector2, translate: *const msdfgen_Vector2) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_Projection_Projection1(__bindgen_tmp.as_mut_ptr(), scale, translate);
        __bindgen_tmp.assume_init()
    }
}
pub const msdfgen_FillRule_FILL_NONZERO: msdfgen_FillRule = 0;
pub const msdfgen_FillRule_FILL_ODD: msdfgen_FillRule = 1;
pub const msdfgen_FillRule_FILL_POSITIVE: msdfgen_FillRule = 2;
pub const msdfgen_FillRule_FILL_NEGATIVE: msdfgen_FillRule = 3;
#[doc = " Fill rule dictates how intersection total is interpreted during rasterization."]
pub type msdfgen_FillRule = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Resolves the number of intersection into a binary fill value based on fill rule."]
    #[link_name = "\u{1}__ZN7msdfgen17interpretFillRuleEiNS_8FillRuleE"]
    pub fn msdfgen_interpretFillRule(
        intersections: ::std::os::raw::c_int,
        fillRule: msdfgen_FillRule,
    ) -> bool;
}
#[doc = " Represents a horizontal scanline intersecting a shape."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_Scanline {
    pub intersections: [u64; 3usize],
    pub lastIndex: ::std::os::raw::c_int,
}
#[doc = " An intersection with the scanline."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_Scanline_Intersection {
    #[doc = " X coordinate."]
    pub x: f64,
    #[doc = " Normalized Y direction of the oriented edge at the point of intersection."]
    pub direction: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msdfgen_Scanline_Intersection() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_Scanline_Intersection>(),
        16usize,
        concat!("Size of: ", stringify!(msdfgen_Scanline_Intersection))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_Scanline_Intersection>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_Scanline_Intersection))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Scanline_Intersection>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Scanline_Intersection),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_direction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Scanline_Intersection>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Scanline_Intersection),
                "::",
                stringify!(direction)
            )
        );
    }
    test_field_direction();
}
#[test]
fn bindgen_test_layout_msdfgen_Scanline() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_Scanline>(),
        32usize,
        concat!("Size of: ", stringify!(msdfgen_Scanline))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_Scanline>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_Scanline))
    );
    fn test_field_intersections() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Scanline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intersections) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Scanline),
                "::",
                stringify!(intersections)
            )
        );
    }
    test_field_intersections();
    fn test_field_lastIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Scanline>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastIndex) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Scanline),
                "::",
                stringify!(lastIndex)
            )
        );
    }
    test_field_lastIndex();
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen8Scanline7overlapERKS0_S2_ddNS_8FillRuleE"]
    pub fn msdfgen_Scanline_overlap(
        a: *const msdfgen_Scanline,
        b: *const msdfgen_Scanline,
        xFrom: f64,
        xTo: f64,
        fillRule: msdfgen_FillRule,
    ) -> f64;
}
extern "C" {
    #[doc = " Populates the intersection list."]
    #[link_name = "\u{1}__ZN7msdfgen8Scanline16setIntersectionsERKNSt3__16vectorINS0_12IntersectionENS1_9allocatorIS3_EEEE"]
    pub fn msdfgen_Scanline_setIntersections(
        this: *mut msdfgen_Scanline,
        intersections: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen8Scanline16setIntersectionsEONSt3__16vectorINS0_12IntersectionENS1_9allocatorIS3_EEEE"]
    pub fn msdfgen_Scanline_setIntersections1(
        this: *mut msdfgen_Scanline,
        intersections: *mut [u64; 3usize],
    );
}
extern "C" {
    #[doc = " Returns the number of intersections left of x."]
    #[link_name = "\u{1}__ZNK7msdfgen8Scanline18countIntersectionsEd"]
    pub fn msdfgen_Scanline_countIntersections(
        this: *const msdfgen_Scanline,
        x: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the total sign of intersections left of x."]
    #[link_name = "\u{1}__ZNK7msdfgen8Scanline16sumIntersectionsEd"]
    pub fn msdfgen_Scanline_sumIntersections(
        this: *const msdfgen_Scanline,
        x: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decides whether the scanline is filled at x based on fill rule."]
    #[link_name = "\u{1}__ZNK7msdfgen8Scanline6filledEdNS_8FillRuleE"]
    pub fn msdfgen_Scanline_filled(
        this: *const msdfgen_Scanline,
        x: f64,
        fillRule: msdfgen_FillRule,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen8ScanlineC1Ev"]
    pub fn msdfgen_Scanline_Scanline(this: *mut msdfgen_Scanline);
}
impl msdfgen_Scanline {
    #[inline]
    pub unsafe fn overlap(
        a: *const msdfgen_Scanline,
        b: *const msdfgen_Scanline,
        xFrom: f64,
        xTo: f64,
        fillRule: msdfgen_FillRule,
    ) -> f64 {
        msdfgen_Scanline_overlap(a, b, xFrom, xTo, fillRule)
    }
    #[inline]
    pub unsafe fn setIntersections(&mut self, intersections: *const [u64; 3usize]) {
        msdfgen_Scanline_setIntersections(self, intersections)
    }
    #[inline]
    pub unsafe fn setIntersections1(&mut self, intersections: *mut [u64; 3usize]) {
        msdfgen_Scanline_setIntersections1(self, intersections)
    }
    #[inline]
    pub unsafe fn countIntersections(&self, x: f64) -> ::std::os::raw::c_int {
        msdfgen_Scanline_countIntersections(self, x)
    }
    #[inline]
    pub unsafe fn sumIntersections(&self, x: f64) -> ::std::os::raw::c_int {
        msdfgen_Scanline_sumIntersections(self, x)
    }
    #[inline]
    pub unsafe fn filled(&self, x: f64, fillRule: msdfgen_FillRule) -> bool {
        msdfgen_Scanline_filled(self, x, fillRule)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_Scanline_Scanline(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Represents a signed distance and alignment, which together can be compared to uniquely determine the closest edge segment."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_SignedDistance {
    pub distance: f64,
    pub dot: f64,
}
#[test]
fn bindgen_test_layout_msdfgen_SignedDistance() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_SignedDistance>(),
        16usize,
        concat!("Size of: ", stringify!(msdfgen_SignedDistance))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_SignedDistance>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_SignedDistance))
    );
    fn test_field_distance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_SignedDistance>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).distance) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_SignedDistance),
                "::",
                stringify!(distance)
            )
        );
    }
    test_field_distance();
    fn test_field_dot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_SignedDistance>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dot) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_SignedDistance),
                "::",
                stringify!(dot)
            )
        );
    }
    test_field_dot();
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen14SignedDistanceC1Ev"]
    pub fn msdfgen_SignedDistance_SignedDistance(this: *mut msdfgen_SignedDistance);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen14SignedDistanceC1Edd"]
    pub fn msdfgen_SignedDistance_SignedDistance1(
        this: *mut msdfgen_SignedDistance,
        dist: f64,
        d: f64,
    );
}
impl msdfgen_SignedDistance {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_SignedDistance_SignedDistance(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(dist: f64, d: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_SignedDistance_SignedDistance1(__bindgen_tmp.as_mut_ptr(), dist, d);
        __bindgen_tmp.assume_init()
    }
}
pub const msdfgen_EdgeColor_BLACK: msdfgen_EdgeColor = 0;
pub const msdfgen_EdgeColor_RED: msdfgen_EdgeColor = 1;
pub const msdfgen_EdgeColor_GREEN: msdfgen_EdgeColor = 2;
pub const msdfgen_EdgeColor_YELLOW: msdfgen_EdgeColor = 3;
pub const msdfgen_EdgeColor_BLUE: msdfgen_EdgeColor = 4;
pub const msdfgen_EdgeColor_MAGENTA: msdfgen_EdgeColor = 5;
pub const msdfgen_EdgeColor_CYAN: msdfgen_EdgeColor = 6;
pub const msdfgen_EdgeColor_WHITE: msdfgen_EdgeColor = 7;
#[doc = " Edge color specifies which color channels an edge belongs to."]
pub type msdfgen_EdgeColor = ::std::os::raw::c_uint;
#[repr(C)]
pub struct msdfgen_EdgeSegment__bindgen_vtable(::std::os::raw::c_void);
#[doc = " An abstract edge segment."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_EdgeSegment {
    pub vtable_: *const msdfgen_EdgeSegment__bindgen_vtable,
    pub color: msdfgen_EdgeColor,
}
#[test]
fn bindgen_test_layout_msdfgen_EdgeSegment() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_EdgeSegment>(),
        16usize,
        concat!("Size of: ", stringify!(msdfgen_EdgeSegment))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_EdgeSegment>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_EdgeSegment))
    );
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_EdgeSegment>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_EdgeSegment),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
}
extern "C" {
    #[doc = " Converts a previously retrieved signed distance from origin to pseudo-distance."]
    #[link_name = "\u{1}__ZNK7msdfgen11EdgeSegment24distanceToPseudoDistanceERNS_14SignedDistanceENS_7Vector2Ed"]
    pub fn msdfgen_EdgeSegment_distanceToPseudoDistance(
        this: *mut ::std::os::raw::c_void,
        distance: *mut msdfgen_SignedDistance,
        origin: msdfgen_Point2,
        param: f64,
    );
}
#[doc = " A line segment."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_LinearSegment {
    pub _base: msdfgen_EdgeSegment,
    pub p: [msdfgen_Point2; 2usize],
}
#[test]
fn bindgen_test_layout_msdfgen_LinearSegment() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_LinearSegment>(),
        48usize,
        concat!("Size of: ", stringify!(msdfgen_LinearSegment))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_LinearSegment>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_LinearSegment))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_LinearSegment>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_LinearSegment),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment6lengthEv"]
    pub fn msdfgen_LinearSegment_length(this: *const msdfgen_LinearSegment) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen13LinearSegmentC1ENS_7Vector2ES1_NS_9EdgeColorE"]
    pub fn msdfgen_LinearSegment_LinearSegment(
        this: *mut msdfgen_LinearSegment,
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    );
}
impl msdfgen_LinearSegment {
    #[inline]
    pub unsafe fn length(&self) -> f64 {
        msdfgen_LinearSegment_length(self)
    }
    #[inline]
    pub unsafe fn new(
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_LinearSegment_LinearSegment(__bindgen_tmp.as_mut_ptr(), p0, p1, edgeColor);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment5cloneEv"]
    pub fn msdfgen_LinearSegment_clone(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut msdfgen_LinearSegment;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment5pointEd"]
    pub fn msdfgen_LinearSegment_point(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Point2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment9directionEd"]
    pub fn msdfgen_LinearSegment_direction(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment15directionChangeEd"]
    pub fn msdfgen_LinearSegment_directionChange(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment14signedDistanceENS_7Vector2ERd"]
    pub fn msdfgen_LinearSegment_signedDistance(
        this: *mut ::std::os::raw::c_void,
        origin: msdfgen_Point2,
        param: *mut f64,
    ) -> msdfgen_SignedDistance;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment21scanlineIntersectionsEPdPid"]
    pub fn msdfgen_LinearSegment_scanlineIntersections(
        this: *mut ::std::os::raw::c_void,
        x: *mut f64,
        dy: *mut ::std::os::raw::c_int,
        y: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment5boundERdS1_S1_S1_"]
    pub fn msdfgen_LinearSegment_bound(
        this: *mut ::std::os::raw::c_void,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen13LinearSegment7reverseEv"]
    pub fn msdfgen_LinearSegment_reverse(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen13LinearSegment14moveStartPointENS_7Vector2E"]
    pub fn msdfgen_LinearSegment_moveStartPoint(
        this: *mut ::std::os::raw::c_void,
        to: msdfgen_Point2,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen13LinearSegment12moveEndPointENS_7Vector2E"]
    pub fn msdfgen_LinearSegment_moveEndPoint(
        this: *mut ::std::os::raw::c_void,
        to: msdfgen_Point2,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen13LinearSegment13splitInThirdsERPNS_11EdgeSegmentES3_S3_"]
    pub fn msdfgen_LinearSegment_splitInThirds(
        this: *mut ::std::os::raw::c_void,
        part1: *mut *mut msdfgen_EdgeSegment,
        part2: *mut *mut msdfgen_EdgeSegment,
        part3: *mut *mut msdfgen_EdgeSegment,
    );
}
#[doc = " A quadratic Bezier curve."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_QuadraticSegment {
    pub _base: msdfgen_EdgeSegment,
    pub p: [msdfgen_Point2; 3usize],
}
#[test]
fn bindgen_test_layout_msdfgen_QuadraticSegment() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_QuadraticSegment>(),
        64usize,
        concat!("Size of: ", stringify!(msdfgen_QuadraticSegment))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_QuadraticSegment>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_QuadraticSegment))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_QuadraticSegment>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_QuadraticSegment),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment6lengthEv"]
    pub fn msdfgen_QuadraticSegment_length(this: *const msdfgen_QuadraticSegment) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment14convertToCubicEv"]
    pub fn msdfgen_QuadraticSegment_convertToCubic(
        this: *const msdfgen_QuadraticSegment,
    ) -> *mut msdfgen_EdgeSegment;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16QuadraticSegmentC1ENS_7Vector2ES1_S1_NS_9EdgeColorE"]
    pub fn msdfgen_QuadraticSegment_QuadraticSegment(
        this: *mut msdfgen_QuadraticSegment,
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    );
}
impl msdfgen_QuadraticSegment {
    #[inline]
    pub unsafe fn length(&self) -> f64 {
        msdfgen_QuadraticSegment_length(self)
    }
    #[inline]
    pub unsafe fn convertToCubic(&self) -> *mut msdfgen_EdgeSegment {
        msdfgen_QuadraticSegment_convertToCubic(self)
    }
    #[inline]
    pub unsafe fn new(
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_QuadraticSegment_QuadraticSegment(
            __bindgen_tmp.as_mut_ptr(),
            p0,
            p1,
            p2,
            edgeColor,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment5cloneEv"]
    pub fn msdfgen_QuadraticSegment_clone(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut msdfgen_QuadraticSegment;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment5pointEd"]
    pub fn msdfgen_QuadraticSegment_point(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Point2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment9directionEd"]
    pub fn msdfgen_QuadraticSegment_direction(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment15directionChangeEd"]
    pub fn msdfgen_QuadraticSegment_directionChange(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment14signedDistanceENS_7Vector2ERd"]
    pub fn msdfgen_QuadraticSegment_signedDistance(
        this: *mut ::std::os::raw::c_void,
        origin: msdfgen_Point2,
        param: *mut f64,
    ) -> msdfgen_SignedDistance;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment21scanlineIntersectionsEPdPid"]
    pub fn msdfgen_QuadraticSegment_scanlineIntersections(
        this: *mut ::std::os::raw::c_void,
        x: *mut f64,
        dy: *mut ::std::os::raw::c_int,
        y: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment5boundERdS1_S1_S1_"]
    pub fn msdfgen_QuadraticSegment_bound(
        this: *mut ::std::os::raw::c_void,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16QuadraticSegment7reverseEv"]
    pub fn msdfgen_QuadraticSegment_reverse(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16QuadraticSegment14moveStartPointENS_7Vector2E"]
    pub fn msdfgen_QuadraticSegment_moveStartPoint(
        this: *mut ::std::os::raw::c_void,
        to: msdfgen_Point2,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16QuadraticSegment12moveEndPointENS_7Vector2E"]
    pub fn msdfgen_QuadraticSegment_moveEndPoint(
        this: *mut ::std::os::raw::c_void,
        to: msdfgen_Point2,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen16QuadraticSegment13splitInThirdsERPNS_11EdgeSegmentES3_S3_"]
    pub fn msdfgen_QuadraticSegment_splitInThirds(
        this: *mut ::std::os::raw::c_void,
        part1: *mut *mut msdfgen_EdgeSegment,
        part2: *mut *mut msdfgen_EdgeSegment,
        part3: *mut *mut msdfgen_EdgeSegment,
    );
}
#[doc = " A cubic Bezier curve."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_CubicSegment {
    pub _base: msdfgen_EdgeSegment,
    pub p: [msdfgen_Point2; 4usize],
}
#[test]
fn bindgen_test_layout_msdfgen_CubicSegment() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_CubicSegment>(),
        80usize,
        concat!("Size of: ", stringify!(msdfgen_CubicSegment))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_CubicSegment>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_CubicSegment))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_CubicSegment>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_CubicSegment),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12CubicSegment10deconvergeEid"]
    pub fn msdfgen_CubicSegment_deconverge(
        this: *mut msdfgen_CubicSegment,
        param: ::std::os::raw::c_int,
        amount: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12CubicSegmentC1ENS_7Vector2ES1_S1_S1_NS_9EdgeColorE"]
    pub fn msdfgen_CubicSegment_CubicSegment(
        this: *mut msdfgen_CubicSegment,
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        p3: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    );
}
impl msdfgen_CubicSegment {
    #[inline]
    pub unsafe fn deconverge(&mut self, param: ::std::os::raw::c_int, amount: f64) {
        msdfgen_CubicSegment_deconverge(self, param, amount)
    }
    #[inline]
    pub unsafe fn new(
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        p3: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_CubicSegment_CubicSegment(__bindgen_tmp.as_mut_ptr(), p0, p1, p2, p3, edgeColor);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment5cloneEv"]
    pub fn msdfgen_CubicSegment_clone(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut msdfgen_CubicSegment;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment5pointEd"]
    pub fn msdfgen_CubicSegment_point(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Point2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment9directionEd"]
    pub fn msdfgen_CubicSegment_direction(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment15directionChangeEd"]
    pub fn msdfgen_CubicSegment_directionChange(
        this: *mut ::std::os::raw::c_void,
        param: f64,
    ) -> msdfgen_Vector2;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment14signedDistanceENS_7Vector2ERd"]
    pub fn msdfgen_CubicSegment_signedDistance(
        this: *mut ::std::os::raw::c_void,
        origin: msdfgen_Point2,
        param: *mut f64,
    ) -> msdfgen_SignedDistance;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment21scanlineIntersectionsEPdPid"]
    pub fn msdfgen_CubicSegment_scanlineIntersections(
        this: *mut ::std::os::raw::c_void,
        x: *mut f64,
        dy: *mut ::std::os::raw::c_int,
        y: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment5boundERdS1_S1_S1_"]
    pub fn msdfgen_CubicSegment_bound(
        this: *mut ::std::os::raw::c_void,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12CubicSegment7reverseEv"]
    pub fn msdfgen_CubicSegment_reverse(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12CubicSegment14moveStartPointENS_7Vector2E"]
    pub fn msdfgen_CubicSegment_moveStartPoint(
        this: *mut ::std::os::raw::c_void,
        to: msdfgen_Point2,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12CubicSegment12moveEndPointENS_7Vector2E"]
    pub fn msdfgen_CubicSegment_moveEndPoint(this: *mut ::std::os::raw::c_void, to: msdfgen_Point2);
}
extern "C" {
    #[link_name = "\u{1}__ZNK7msdfgen12CubicSegment13splitInThirdsERPNS_11EdgeSegmentES3_S3_"]
    pub fn msdfgen_CubicSegment_splitInThirds(
        this: *mut ::std::os::raw::c_void,
        part1: *mut *mut msdfgen_EdgeSegment,
        part2: *mut *mut msdfgen_EdgeSegment,
        part3: *mut *mut msdfgen_EdgeSegment,
    );
}
#[doc = " Container for a single edge of dynamic type."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_EdgeHolder {
    pub edgeSegment: *mut msdfgen_EdgeSegment,
}
#[test]
fn bindgen_test_layout_msdfgen_EdgeHolder() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_EdgeHolder>(),
        8usize,
        concat!("Size of: ", stringify!(msdfgen_EdgeHolder))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_EdgeHolder>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_EdgeHolder))
    );
    fn test_field_edgeSegment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_EdgeHolder>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).edgeSegment) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_EdgeHolder),
                "::",
                stringify!(edgeSegment)
            )
        );
    }
    test_field_edgeSegment();
}
extern "C" {
    #[doc = " Swaps the edges held by a and b."]
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolder4swapERS0_S1_"]
    pub fn msdfgen_EdgeHolder_swap(a: *mut msdfgen_EdgeHolder, b: *mut msdfgen_EdgeHolder);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderC1Ev"]
    pub fn msdfgen_EdgeHolder_EdgeHolder(this: *mut msdfgen_EdgeHolder);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderC1EPNS_11EdgeSegmentE"]
    pub fn msdfgen_EdgeHolder_EdgeHolder1(
        this: *mut msdfgen_EdgeHolder,
        segment: *mut msdfgen_EdgeSegment,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderC1ENS_7Vector2ES1_NS_9EdgeColorE"]
    pub fn msdfgen_EdgeHolder_EdgeHolder2(
        this: *mut msdfgen_EdgeHolder,
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderC1ENS_7Vector2ES1_S1_NS_9EdgeColorE"]
    pub fn msdfgen_EdgeHolder_EdgeHolder3(
        this: *mut msdfgen_EdgeHolder,
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderC1ENS_7Vector2ES1_S1_S1_NS_9EdgeColorE"]
    pub fn msdfgen_EdgeHolder_EdgeHolder4(
        this: *mut msdfgen_EdgeHolder,
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        p3: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderC1ERKS0_"]
    pub fn msdfgen_EdgeHolder_EdgeHolder5(
        this: *mut msdfgen_EdgeHolder,
        orig: *const msdfgen_EdgeHolder,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderC1EOS0_"]
    pub fn msdfgen_EdgeHolder_EdgeHolder6(
        this: *mut msdfgen_EdgeHolder,
        orig: *mut msdfgen_EdgeHolder,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen10EdgeHolderD1Ev"]
    pub fn msdfgen_EdgeHolder_EdgeHolder_destructor(this: *mut msdfgen_EdgeHolder);
}
impl msdfgen_EdgeHolder {
    #[inline]
    pub unsafe fn swap(a: *mut msdfgen_EdgeHolder, b: *mut msdfgen_EdgeHolder) {
        msdfgen_EdgeHolder_swap(a, b)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_EdgeHolder_EdgeHolder(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(segment: *mut msdfgen_EdgeSegment) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_EdgeHolder_EdgeHolder1(__bindgen_tmp.as_mut_ptr(), segment);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_EdgeHolder_EdgeHolder2(__bindgen_tmp.as_mut_ptr(), p0, p1, edgeColor);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_EdgeHolder_EdgeHolder3(__bindgen_tmp.as_mut_ptr(), p0, p1, p2, edgeColor);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        p0: msdfgen_Point2,
        p1: msdfgen_Point2,
        p2: msdfgen_Point2,
        p3: msdfgen_Point2,
        edgeColor: msdfgen_EdgeColor,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_EdgeHolder_EdgeHolder4(__bindgen_tmp.as_mut_ptr(), p0, p1, p2, p3, edgeColor);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(orig: *const msdfgen_EdgeHolder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_EdgeHolder_EdgeHolder5(__bindgen_tmp.as_mut_ptr(), orig);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(orig: *mut msdfgen_EdgeHolder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_EdgeHolder_EdgeHolder6(__bindgen_tmp.as_mut_ptr(), orig);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        msdfgen_EdgeHolder_EdgeHolder_destructor(self)
    }
}
#[doc = " A single closed contour of a shape."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_Contour {
    #[doc = " The sequence of edges that make up the contour."]
    pub edges: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_msdfgen_Contour() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_Contour>(),
        24usize,
        concat!("Size of: ", stringify!(msdfgen_Contour))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_Contour>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_Contour))
    );
    fn test_field_edges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Contour>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).edges) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Contour),
                "::",
                stringify!(edges)
            )
        );
    }
    test_field_edges();
}
extern "C" {
    #[doc = " Adds an edge to the contour."]
    #[link_name = "\u{1}__ZN7msdfgen7Contour7addEdgeERKNS_10EdgeHolderE"]
    pub fn msdfgen_Contour_addEdge(this: *mut msdfgen_Contour, edge: *const msdfgen_EdgeHolder);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7Contour7addEdgeEONS_10EdgeHolderE"]
    pub fn msdfgen_Contour_addEdge1(this: *mut msdfgen_Contour, edge: *mut msdfgen_EdgeHolder);
}
extern "C" {
    #[doc = " Creates a new edge in the contour and returns its reference."]
    #[link_name = "\u{1}__ZN7msdfgen7Contour7addEdgeEv"]
    pub fn msdfgen_Contour_addEdge2(this: *mut msdfgen_Contour) -> *mut msdfgen_EdgeHolder;
}
extern "C" {
    #[doc = " Adjusts the bounding box to fit the contour."]
    #[link_name = "\u{1}__ZNK7msdfgen7Contour5boundERdS1_S1_S1_"]
    pub fn msdfgen_Contour_bound(
        this: *const msdfgen_Contour,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
    );
}
extern "C" {
    #[doc = " Adjusts the bounding box to fit the contour border's mitered corners."]
    #[link_name = "\u{1}__ZNK7msdfgen7Contour11boundMitersERdS1_S1_S1_ddi"]
    pub fn msdfgen_Contour_boundMiters(
        this: *const msdfgen_Contour,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
        border: f64,
        miterLimit: f64,
        polarity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Computes the winding of the contour. Returns 1 if positive, -1 if negative."]
    #[link_name = "\u{1}__ZNK7msdfgen7Contour7windingEv"]
    pub fn msdfgen_Contour_winding(this: *const msdfgen_Contour) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reverses the sequence of edges on the contour."]
    #[link_name = "\u{1}__ZN7msdfgen7Contour7reverseEv"]
    pub fn msdfgen_Contour_reverse(this: *mut msdfgen_Contour);
}
impl msdfgen_Contour {
    #[inline]
    pub unsafe fn addEdge(&mut self, edge: *const msdfgen_EdgeHolder) {
        msdfgen_Contour_addEdge(self, edge)
    }
    #[inline]
    pub unsafe fn addEdge1(&mut self, edge: *mut msdfgen_EdgeHolder) {
        msdfgen_Contour_addEdge1(self, edge)
    }
    #[inline]
    pub unsafe fn addEdge2(&mut self) -> *mut msdfgen_EdgeHolder {
        msdfgen_Contour_addEdge2(self)
    }
    #[inline]
    pub unsafe fn bound(&self, l: *mut f64, b: *mut f64, r: *mut f64, t: *mut f64) {
        msdfgen_Contour_bound(self, l, b, r, t)
    }
    #[inline]
    pub unsafe fn boundMiters(
        &self,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
        border: f64,
        miterLimit: f64,
        polarity: ::std::os::raw::c_int,
    ) {
        msdfgen_Contour_boundMiters(self, l, b, r, t, border, miterLimit, polarity)
    }
    #[inline]
    pub unsafe fn winding(&self) -> ::std::os::raw::c_int {
        msdfgen_Contour_winding(self)
    }
    #[inline]
    pub unsafe fn reverse(&mut self) {
        msdfgen_Contour_reverse(self)
    }
}
#[doc = " Vector shape representation."]
#[repr(C)]
#[derive(Debug)]
pub struct msdfgen_Shape {
    #[doc = " The list of contours the shape consists of."]
    pub contours: [u64; 3usize],
    #[doc = " Specifies whether the shape uses bottom-to-top (false) or top-to-bottom (true) Y coordinates."]
    pub inverseYAxis: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_Shape_Bounds {
    pub l: f64,
    pub b: f64,
    pub r: f64,
    pub t: f64,
}
#[test]
fn bindgen_test_layout_msdfgen_Shape_Bounds() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_Shape_Bounds>(),
        32usize,
        concat!("Size of: ", stringify!(msdfgen_Shape_Bounds))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_Shape_Bounds>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_Shape_Bounds))
    );
    fn test_field_l() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Shape_Bounds>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Shape_Bounds),
                "::",
                stringify!(l)
            )
        );
    }
    test_field_l();
    fn test_field_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Shape_Bounds>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Shape_Bounds),
                "::",
                stringify!(b)
            )
        );
    }
    test_field_b();
    fn test_field_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Shape_Bounds>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Shape_Bounds),
                "::",
                stringify!(r)
            )
        );
    }
    test_field_r();
    fn test_field_t() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Shape_Bounds>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Shape_Bounds),
                "::",
                stringify!(t)
            )
        );
    }
    test_field_t();
}
#[test]
fn bindgen_test_layout_msdfgen_Shape() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_Shape>(),
        32usize,
        concat!("Size of: ", stringify!(msdfgen_Shape))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_Shape>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_Shape))
    );
    fn test_field_contours() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Shape>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).contours) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Shape),
                "::",
                stringify!(contours)
            )
        );
    }
    test_field_contours();
    fn test_field_inverseYAxis() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_Shape>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inverseYAxis) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_Shape),
                "::",
                stringify!(inverseYAxis)
            )
        );
    }
    test_field_inverseYAxis();
}
extern "C" {
    #[doc = " Adds a contour."]
    #[link_name = "\u{1}__ZN7msdfgen5Shape10addContourERKNS_7ContourE"]
    pub fn msdfgen_Shape_addContour(this: *mut msdfgen_Shape, contour: *const msdfgen_Contour);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen5Shape10addContourEONS_7ContourE"]
    pub fn msdfgen_Shape_addContour1(this: *mut msdfgen_Shape, contour: *mut msdfgen_Contour);
}
extern "C" {
    #[doc = " Adds a blank contour and returns its reference."]
    #[link_name = "\u{1}__ZN7msdfgen5Shape10addContourEv"]
    pub fn msdfgen_Shape_addContour2(this: *mut msdfgen_Shape) -> *mut msdfgen_Contour;
}
extern "C" {
    #[doc = " Normalizes the shape geometry for distance field generation."]
    #[link_name = "\u{1}__ZN7msdfgen5Shape9normalizeEv"]
    pub fn msdfgen_Shape_normalize(this: *mut msdfgen_Shape);
}
extern "C" {
    #[doc = " Performs basic checks to determine if the object represents a valid shape."]
    #[link_name = "\u{1}__ZNK7msdfgen5Shape8validateEv"]
    pub fn msdfgen_Shape_validate(this: *const msdfgen_Shape) -> bool;
}
extern "C" {
    #[doc = " Adjusts the bounding box to fit the shape."]
    #[link_name = "\u{1}__ZNK7msdfgen5Shape5boundERdS1_S1_S1_"]
    pub fn msdfgen_Shape_bound(
        this: *const msdfgen_Shape,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
    );
}
extern "C" {
    #[doc = " Adjusts the bounding box to fit the shape border's mitered corners."]
    #[link_name = "\u{1}__ZNK7msdfgen5Shape11boundMitersERdS1_S1_S1_ddi"]
    pub fn msdfgen_Shape_boundMiters(
        this: *const msdfgen_Shape,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
        border: f64,
        miterLimit: f64,
        polarity: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Computes the minimum bounding box that fits the shape, optionally with a (mitered) border."]
    #[link_name = "\u{1}__ZNK7msdfgen5Shape9getBoundsEddi"]
    pub fn msdfgen_Shape_getBounds(
        this: *const msdfgen_Shape,
        border: f64,
        miterLimit: f64,
        polarity: ::std::os::raw::c_int,
    ) -> msdfgen_Shape_Bounds;
}
extern "C" {
    #[doc = " Outputs the scanline that intersects the shape at y."]
    #[link_name = "\u{1}__ZNK7msdfgen5Shape8scanlineERNS_8ScanlineEd"]
    pub fn msdfgen_Shape_scanline(this: *const msdfgen_Shape, line: *mut msdfgen_Scanline, y: f64);
}
extern "C" {
    #[doc = " Returns the total number of edge segments"]
    #[link_name = "\u{1}__ZNK7msdfgen5Shape9edgeCountEv"]
    pub fn msdfgen_Shape_edgeCount(this: *const msdfgen_Shape) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Assumes its contours are unoriented (even-odd fill rule). Attempts to orient them to conform to the non-zero winding rule."]
    #[link_name = "\u{1}__ZN7msdfgen5Shape14orientContoursEv"]
    pub fn msdfgen_Shape_orientContours(this: *mut msdfgen_Shape);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen5ShapeC1Ev"]
    pub fn msdfgen_Shape_Shape(this: *mut msdfgen_Shape);
}
impl msdfgen_Shape {
    #[inline]
    pub unsafe fn addContour(&mut self, contour: *const msdfgen_Contour) {
        msdfgen_Shape_addContour(self, contour)
    }
    #[inline]
    pub unsafe fn addContour1(&mut self, contour: *mut msdfgen_Contour) {
        msdfgen_Shape_addContour1(self, contour)
    }
    #[inline]
    pub unsafe fn addContour2(&mut self) -> *mut msdfgen_Contour {
        msdfgen_Shape_addContour2(self)
    }
    #[inline]
    pub unsafe fn normalize(&mut self) {
        msdfgen_Shape_normalize(self)
    }
    #[inline]
    pub unsafe fn validate(&self) -> bool {
        msdfgen_Shape_validate(self)
    }
    #[inline]
    pub unsafe fn bound(&self, l: *mut f64, b: *mut f64, r: *mut f64, t: *mut f64) {
        msdfgen_Shape_bound(self, l, b, r, t)
    }
    #[inline]
    pub unsafe fn boundMiters(
        &self,
        l: *mut f64,
        b: *mut f64,
        r: *mut f64,
        t: *mut f64,
        border: f64,
        miterLimit: f64,
        polarity: ::std::os::raw::c_int,
    ) {
        msdfgen_Shape_boundMiters(self, l, b, r, t, border, miterLimit, polarity)
    }
    #[inline]
    pub unsafe fn getBounds(
        &self,
        border: f64,
        miterLimit: f64,
        polarity: ::std::os::raw::c_int,
    ) -> msdfgen_Shape_Bounds {
        msdfgen_Shape_getBounds(self, border, miterLimit, polarity)
    }
    #[inline]
    pub unsafe fn scanline(&self, line: *mut msdfgen_Scanline, y: f64) {
        msdfgen_Shape_scanline(self, line, y)
    }
    #[inline]
    pub unsafe fn edgeCount(&self) -> ::std::os::raw::c_int {
        msdfgen_Shape_edgeCount(self)
    }
    #[inline]
    pub unsafe fn orientContours(&mut self) {
        msdfgen_Shape_orientContours(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        msdfgen_Shape_Shape(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub type msdfgen_byte = ::std::os::raw::c_uchar;
extern "C" {
    #[doc = " Assigns colors to edges of the shape in accordance to the multi-channel distance field technique."]
    #[doc = "  May split some edges if necessary."]
    #[doc = "  angleThreshold specifies the maximum angle (in radians) to be considered a corner, for example 3 (~172 degrees)."]
    #[doc = "  Values below 1/2 PI will be treated as the external angle."]
    #[link_name = "\u{1}__ZN7msdfgen18edgeColoringSimpleERNS_5ShapeEdy"]
    pub fn msdfgen_edgeColoringSimple(
        shape: *mut msdfgen_Shape,
        angleThreshold: f64,
        seed: ::std::os::raw::c_ulonglong,
    );
}
extern "C" {
    #[doc = " The alternative \"ink trap\" coloring strategy is designed for better results with typefaces"]
    #[doc = "  that use ink traps as a design feature. It guarantees that even if all edges that are shorter than"]
    #[doc = "  both their neighboring edges are removed, the coloring remains consistent with the established rules."]
    #[link_name = "\u{1}__ZN7msdfgen19edgeColoringInkTrapERNS_5ShapeEdy"]
    pub fn msdfgen_edgeColoringInkTrap(
        shape: *mut msdfgen_Shape,
        angleThreshold: f64,
        seed: ::std::os::raw::c_ulonglong,
    );
}
extern "C" {
    #[doc = " The alternative coloring by distance tries to use different colors for edges that are close together."]
    #[doc = "  This should theoretically be the best strategy on average. However, since it needs to compute the distance"]
    #[doc = "  between all pairs of edges, and perform a graph optimization task, it is much slower than the rest."]
    #[link_name = "\u{1}__ZN7msdfgen22edgeColoringByDistanceERNS_5ShapeEdy"]
    pub fn msdfgen_edgeColoringByDistance(
        shape: *mut msdfgen_Shape,
        angleThreshold: f64,
        seed: ::std::os::raw::c_ulonglong,
    );
}
#[doc = " The configuration of the MSDF error correction pass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_ErrorCorrectionConfig {
    pub mode: msdfgen_ErrorCorrectionConfig_Mode,
    pub distanceCheckMode: msdfgen_ErrorCorrectionConfig_DistanceCheckMode,
    #[doc = " The minimum ratio between the actual and maximum expected distance delta to be considered an error."]
    pub minDeviationRatio: f64,
    #[doc = " The minimum ratio between the pre-correction distance error and the post-correction distance error. Has no effect for DO_NOT_CHECK_DISTANCE."]
    pub minImproveRatio: f64,
    #[doc = " An optional buffer to avoid dynamic allocation. Must have at least as many bytes as the MSDF has pixels."]
    pub buffer: *mut msdfgen_byte,
}
#[doc = " Skips error correction pass."]
pub const msdfgen_ErrorCorrectionConfig_Mode_DISABLED: msdfgen_ErrorCorrectionConfig_Mode = 0;
#[doc = " Corrects all discontinuities of the distance field regardless if edges are adversely affected."]
pub const msdfgen_ErrorCorrectionConfig_Mode_INDISCRIMINATE: msdfgen_ErrorCorrectionConfig_Mode = 1;
#[doc = " Corrects artifacts at edges and other discontinuous distances only if it does not affect edges or corners."]
pub const msdfgen_ErrorCorrectionConfig_Mode_EDGE_PRIORITY: msdfgen_ErrorCorrectionConfig_Mode = 2;
#[doc = " Only corrects artifacts at edges."]
pub const msdfgen_ErrorCorrectionConfig_Mode_EDGE_ONLY: msdfgen_ErrorCorrectionConfig_Mode = 3;
#[doc = " Mode of operation."]
pub type msdfgen_ErrorCorrectionConfig_Mode = ::std::os::raw::c_uint;
#[doc = " Never computes exact shape distance."]
pub const msdfgen_ErrorCorrectionConfig_DistanceCheckMode_DO_NOT_CHECK_DISTANCE:
    msdfgen_ErrorCorrectionConfig_DistanceCheckMode = 0;
#[doc = " Only computes exact shape distance at edges. Provides a good balance between speed and precision."]
pub const msdfgen_ErrorCorrectionConfig_DistanceCheckMode_CHECK_DISTANCE_AT_EDGE:
    msdfgen_ErrorCorrectionConfig_DistanceCheckMode = 1;
#[doc = " Computes and compares the exact shape distance for each suspected artifact."]
pub const msdfgen_ErrorCorrectionConfig_DistanceCheckMode_ALWAYS_CHECK_DISTANCE:
    msdfgen_ErrorCorrectionConfig_DistanceCheckMode = 2;
#[doc = " Configuration of whether to use an algorithm that computes the exact shape distance at the positions of suspected artifacts. This algorithm can be much slower."]
pub type msdfgen_ErrorCorrectionConfig_DistanceCheckMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " The default value of minDeviationRatio."]
    #[link_name = "\u{1}__ZN7msdfgen21ErrorCorrectionConfig24defaultMinDeviationRatioE"]
    pub static msdfgen_ErrorCorrectionConfig_defaultMinDeviationRatio: f64;
}
extern "C" {
    #[doc = " The default value of minImproveRatio."]
    #[link_name = "\u{1}__ZN7msdfgen21ErrorCorrectionConfig22defaultMinImproveRatioE"]
    pub static msdfgen_ErrorCorrectionConfig_defaultMinImproveRatio: f64;
}
#[test]
fn bindgen_test_layout_msdfgen_ErrorCorrectionConfig() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_ErrorCorrectionConfig>(),
        32usize,
        concat!("Size of: ", stringify!(msdfgen_ErrorCorrectionConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_ErrorCorrectionConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_ErrorCorrectionConfig))
    );
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_ErrorCorrectionConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_ErrorCorrectionConfig),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_distanceCheckMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_ErrorCorrectionConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).distanceCheckMode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_ErrorCorrectionConfig),
                "::",
                stringify!(distanceCheckMode)
            )
        );
    }
    test_field_distanceCheckMode();
    fn test_field_minDeviationRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_ErrorCorrectionConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minDeviationRatio) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_ErrorCorrectionConfig),
                "::",
                stringify!(minDeviationRatio)
            )
        );
    }
    test_field_minDeviationRatio();
    fn test_field_minImproveRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_ErrorCorrectionConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImproveRatio) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_ErrorCorrectionConfig),
                "::",
                stringify!(minImproveRatio)
            )
        );
    }
    test_field_minImproveRatio();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_ErrorCorrectionConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_ErrorCorrectionConfig),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
#[doc = " The configuration of the distance field generator algorithm."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_GeneratorConfig {
    #[doc = " Specifies whether to use the version of the algorithm that supports overlapping contours with the same winding. May be set to false to improve performance when no such contours are present."]
    pub overlapSupport: bool,
}
#[test]
fn bindgen_test_layout_msdfgen_GeneratorConfig() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_GeneratorConfig>(),
        1usize,
        concat!("Size of: ", stringify!(msdfgen_GeneratorConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_GeneratorConfig>(),
        1usize,
        concat!("Alignment of ", stringify!(msdfgen_GeneratorConfig))
    );
    fn test_field_overlapSupport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_GeneratorConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overlapSupport) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_GeneratorConfig),
                "::",
                stringify!(overlapSupport)
            )
        );
    }
    test_field_overlapSupport();
}
#[doc = " The configuration of the multi-channel distance field generator algorithm."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msdfgen_MSDFGeneratorConfig {
    pub _base: msdfgen_GeneratorConfig,
    #[doc = " Configuration of the error correction pass."]
    pub errorCorrection: msdfgen_ErrorCorrectionConfig,
}
#[test]
fn bindgen_test_layout_msdfgen_MSDFGeneratorConfig() {
    assert_eq!(
        ::std::mem::size_of::<msdfgen_MSDFGeneratorConfig>(),
        40usize,
        concat!("Size of: ", stringify!(msdfgen_MSDFGeneratorConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<msdfgen_MSDFGeneratorConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(msdfgen_MSDFGeneratorConfig))
    );
    fn test_field_errorCorrection() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msdfgen_MSDFGeneratorConfig>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errorCorrection) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msdfgen_MSDFGeneratorConfig),
                "::",
                stringify!(errorCorrection)
            )
        );
    }
    test_field_errorCorrection();
}
extern "C" {
    #[doc = " Predicts potential artifacts caused by the interpolation of the MSDF and corrects them by converting nearby texels to single-channel."]
    #[link_name = "\u{1}__ZN7msdfgen19msdfErrorCorrectionERKNS_9BitmapRefIfLi3EEERKNS_5ShapeERKNS_10ProjectionEdRKNS_19MSDFGeneratorConfigE"]
    pub fn msdfgen_msdfErrorCorrection(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        range: f64,
        config: *const msdfgen_MSDFGeneratorConfig,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen19msdfErrorCorrectionERKNS_9BitmapRefIfLi4EEERKNS_5ShapeERKNS_10ProjectionEdRKNS_19MSDFGeneratorConfigE"]
    pub fn msdfgen_msdfErrorCorrection1(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        range: f64,
        config: *const msdfgen_MSDFGeneratorConfig,
    );
}
extern "C" {
    #[doc = " Applies the simplified error correction to all discontiunous distances (INDISCRIMINATE mode). Does not need shape or translation."]
    #[link_name = "\u{1}__ZN7msdfgen31msdfFastDistanceErrorCorrectionERKNS_9BitmapRefIfLi3EEERKNS_10ProjectionEdd"]
    pub fn msdfgen_msdfFastDistanceErrorCorrection(
        sdf: *const u8,
        projection: *const msdfgen_Projection,
        range: f64,
        minDeviationRatio: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen31msdfFastDistanceErrorCorrectionERKNS_9BitmapRefIfLi4EEERKNS_10ProjectionEdd"]
    pub fn msdfgen_msdfFastDistanceErrorCorrection1(
        sdf: *const u8,
        projection: *const msdfgen_Projection,
        range: f64,
        minDeviationRatio: f64,
    );
}
extern "C" {
    #[doc = " Applies the simplified error correction to edges only (EDGE_ONLY mode). Does not need shape or translation."]
    #[link_name = "\u{1}__ZN7msdfgen27msdfFastEdgeErrorCorrectionERKNS_9BitmapRefIfLi3EEERKNS_10ProjectionEdd"]
    pub fn msdfgen_msdfFastEdgeErrorCorrection(
        sdf: *const u8,
        projection: *const msdfgen_Projection,
        range: f64,
        minDeviationRatio: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen27msdfFastEdgeErrorCorrectionERKNS_9BitmapRefIfLi4EEERKNS_10ProjectionEdd"]
    pub fn msdfgen_msdfFastEdgeErrorCorrection1(
        sdf: *const u8,
        projection: *const msdfgen_Projection,
        range: f64,
        minDeviationRatio: f64,
    );
}
extern "C" {
    #[doc = " The original version of the error correction algorithm."]
    #[link_name = "\u{1}__ZN7msdfgen26msdfErrorCorrection_legacyERKNS_9BitmapRefIfLi3EEERKNS_7Vector2E"]
    pub fn msdfgen_msdfErrorCorrection_legacy(output: *const u8, threshold: *const msdfgen_Vector2);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen26msdfErrorCorrection_legacyERKNS_9BitmapRefIfLi4EEERKNS_7Vector2E"]
    pub fn msdfgen_msdfErrorCorrection_legacy1(
        output: *const u8,
        threshold: *const msdfgen_Vector2,
    );
}
extern "C" {
    #[doc = " Reconstructs the shape's appearance into output from the distance field sdf."]
    #[link_name = "\u{1}__ZN7msdfgen9renderSDFERKNS_9BitmapRefIfLi1EEERKNS_14BitmapConstRefIfLi1EEEdf"]
    pub fn msdfgen_renderSDF(output: *const u8, sdf: *const u8, pxRange: f64, midValue: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen9renderSDFERKNS_9BitmapRefIfLi3EEERKNS_14BitmapConstRefIfLi1EEEdf"]
    pub fn msdfgen_renderSDF1(output: *const u8, sdf: *const u8, pxRange: f64, midValue: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen9renderSDFERKNS_9BitmapRefIfLi1EEERKNS_14BitmapConstRefIfLi3EEEdf"]
    pub fn msdfgen_renderSDF2(output: *const u8, sdf: *const u8, pxRange: f64, midValue: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen9renderSDFERKNS_9BitmapRefIfLi3EEERKNS_14BitmapConstRefIfLi3EEEdf"]
    pub fn msdfgen_renderSDF3(output: *const u8, sdf: *const u8, pxRange: f64, midValue: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen9renderSDFERKNS_9BitmapRefIfLi1EEERKNS_14BitmapConstRefIfLi4EEEdf"]
    pub fn msdfgen_renderSDF4(output: *const u8, sdf: *const u8, pxRange: f64, midValue: f32);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen9renderSDFERKNS_9BitmapRefIfLi4EEERKNS_14BitmapConstRefIfLi4EEEdf"]
    pub fn msdfgen_renderSDF5(output: *const u8, sdf: *const u8, pxRange: f64, midValue: f32);
}
extern "C" {
    #[doc = " Snaps the values of the floating-point bitmaps into one of the 256 values representable in a standard 8-bit bitmap."]
    #[link_name = "\u{1}__ZN7msdfgen12simulate8bitERKNS_9BitmapRefIfLi1EEE"]
    pub fn msdfgen_simulate8bit(bitmap: *const u8);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12simulate8bitERKNS_9BitmapRefIfLi3EEE"]
    pub fn msdfgen_simulate8bit1(bitmap: *const u8);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12simulate8bitERKNS_9BitmapRefIfLi4EEE"]
    pub fn msdfgen_simulate8bit2(bitmap: *const u8);
}
extern "C" {
    #[doc = " Rasterizes the shape into a monochrome bitmap."]
    #[link_name = "\u{1}__ZN7msdfgen9rasterizeERKNS_9BitmapRefIfLi1EEERKNS_5ShapeERKNS_10ProjectionENS_8FillRuleE"]
    pub fn msdfgen_rasterize(
        output: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[doc = " Fixes the sign of the input signed distance field, so that it matches the shape's rasterized fill."]
    #[link_name = "\u{1}__ZN7msdfgen22distanceSignCorrectionERKNS_9BitmapRefIfLi1EEERKNS_5ShapeERKNS_10ProjectionENS_8FillRuleE"]
    pub fn msdfgen_distanceSignCorrection(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen22distanceSignCorrectionERKNS_9BitmapRefIfLi3EEERKNS_5ShapeERKNS_10ProjectionENS_8FillRuleE"]
    pub fn msdfgen_distanceSignCorrection1(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen22distanceSignCorrectionERKNS_9BitmapRefIfLi4EEERKNS_5ShapeERKNS_10ProjectionENS_8FillRuleE"]
    pub fn msdfgen_distanceSignCorrection2(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen9rasterizeERKNS_9BitmapRefIfLi1EEERKNS_5ShapeERKNS_7Vector2ES9_NS_8FillRuleE"]
    pub fn msdfgen_rasterize1(
        output: *const u8,
        shape: *const msdfgen_Shape,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen22distanceSignCorrectionERKNS_9BitmapRefIfLi1EEERKNS_5ShapeERKNS_7Vector2ES9_NS_8FillRuleE"]
    pub fn msdfgen_distanceSignCorrection3(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen22distanceSignCorrectionERKNS_9BitmapRefIfLi3EEERKNS_5ShapeERKNS_7Vector2ES9_NS_8FillRuleE"]
    pub fn msdfgen_distanceSignCorrection4(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen22distanceSignCorrectionERKNS_9BitmapRefIfLi4EEERKNS_5ShapeERKNS_7Vector2ES9_NS_8FillRuleE"]
    pub fn msdfgen_distanceSignCorrection5(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        fillRule: msdfgen_FillRule,
    );
}
extern "C" {
    #[doc = " Analytically constructs a scanline at y evaluating fill by linear interpolation of the SDF."]
    #[link_name = "\u{1}__ZN7msdfgen11scanlineSDFERNS_8ScanlineERKNS_14BitmapConstRefIfLi1EEERKNS_10ProjectionEdb"]
    pub fn msdfgen_scanlineSDF(
        line: *mut msdfgen_Scanline,
        sdf: *const u8,
        projection: *const msdfgen_Projection,
        y: f64,
        inverseYAxis: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen11scanlineSDFERNS_8ScanlineERKNS_14BitmapConstRefIfLi3EEERKNS_10ProjectionEdb"]
    pub fn msdfgen_scanlineSDF1(
        line: *mut msdfgen_Scanline,
        sdf: *const u8,
        projection: *const msdfgen_Projection,
        y: f64,
        inverseYAxis: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen11scanlineSDFERNS_8ScanlineERKNS_14BitmapConstRefIfLi4EEERKNS_10ProjectionEdb"]
    pub fn msdfgen_scanlineSDF2(
        line: *mut msdfgen_Scanline,
        sdf: *const u8,
        projection: *const msdfgen_Projection,
        y: f64,
        inverseYAxis: bool,
    );
}
extern "C" {
    #[doc = " Estimates the portion of the area that will be filled incorrectly when rendering using the SDF."]
    #[link_name = "\u{1}__ZN7msdfgen16estimateSDFErrorERKNS_14BitmapConstRefIfLi1EEERKNS_5ShapeERKNS_10ProjectionEiNS_8FillRuleE"]
    pub fn msdfgen_estimateSDFError(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        scanlinesPerRow: ::std::os::raw::c_int,
        fillRule: msdfgen_FillRule,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16estimateSDFErrorERKNS_14BitmapConstRefIfLi3EEERKNS_5ShapeERKNS_10ProjectionEiNS_8FillRuleE"]
    pub fn msdfgen_estimateSDFError1(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        scanlinesPerRow: ::std::os::raw::c_int,
        fillRule: msdfgen_FillRule,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16estimateSDFErrorERKNS_14BitmapConstRefIfLi4EEERKNS_5ShapeERKNS_10ProjectionEiNS_8FillRuleE"]
    pub fn msdfgen_estimateSDFError2(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        scanlinesPerRow: ::std::os::raw::c_int,
        fillRule: msdfgen_FillRule,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen11scanlineSDFERNS_8ScanlineERKNS_14BitmapConstRefIfLi1EEERKNS_7Vector2ES8_bd"]
    pub fn msdfgen_scanlineSDF3(
        line: *mut msdfgen_Scanline,
        sdf: *const u8,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        inverseYAxis: bool,
        y: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen11scanlineSDFERNS_8ScanlineERKNS_14BitmapConstRefIfLi3EEERKNS_7Vector2ES8_bd"]
    pub fn msdfgen_scanlineSDF4(
        line: *mut msdfgen_Scanline,
        sdf: *const u8,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        inverseYAxis: bool,
        y: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen11scanlineSDFERNS_8ScanlineERKNS_14BitmapConstRefIfLi4EEERKNS_7Vector2ES8_bd"]
    pub fn msdfgen_scanlineSDF5(
        line: *mut msdfgen_Scanline,
        sdf: *const u8,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        inverseYAxis: bool,
        y: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16estimateSDFErrorERKNS_14BitmapConstRefIfLi1EEERKNS_5ShapeERKNS_7Vector2ES9_iNS_8FillRuleE"]
    pub fn msdfgen_estimateSDFError3(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        scanlinesPerRow: ::std::os::raw::c_int,
        fillRule: msdfgen_FillRule,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16estimateSDFErrorERKNS_14BitmapConstRefIfLi3EEERKNS_5ShapeERKNS_7Vector2ES9_iNS_8FillRuleE"]
    pub fn msdfgen_estimateSDFError4(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        scanlinesPerRow: ::std::os::raw::c_int,
        fillRule: msdfgen_FillRule,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16estimateSDFErrorERKNS_14BitmapConstRefIfLi4EEERKNS_5ShapeERKNS_7Vector2ES9_iNS_8FillRuleE"]
    pub fn msdfgen_estimateSDFError5(
        sdf: *const u8,
        shape: *const msdfgen_Shape,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        scanlinesPerRow: ::std::os::raw::c_int,
        fillRule: msdfgen_FillRule,
    ) -> f64;
}
extern "C" {
    #[doc = " Saves the bitmap as a BMP file."]
    #[link_name = "\u{1}__ZN7msdfgen7saveBmpERKNS_14BitmapConstRefIhLi1EEEPKc"]
    pub fn msdfgen_saveBmp(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7saveBmpERKNS_14BitmapConstRefIhLi3EEEPKc"]
    pub fn msdfgen_saveBmp1(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7saveBmpERKNS_14BitmapConstRefIhLi4EEEPKc"]
    pub fn msdfgen_saveBmp2(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7saveBmpERKNS_14BitmapConstRefIfLi1EEEPKc"]
    pub fn msdfgen_saveBmp3(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7saveBmpERKNS_14BitmapConstRefIfLi3EEEPKc"]
    pub fn msdfgen_saveBmp4(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen7saveBmpERKNS_14BitmapConstRefIfLi4EEEPKc"]
    pub fn msdfgen_saveBmp5(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Saves the bitmap as an uncompressed floating-point TIFF file."]
    #[link_name = "\u{1}__ZN7msdfgen8saveTiffERKNS_14BitmapConstRefIfLi1EEEPKc"]
    pub fn msdfgen_saveTiff(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen8saveTiffERKNS_14BitmapConstRefIfLi3EEEPKc"]
    pub fn msdfgen_saveTiff1(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen8saveTiffERKNS_14BitmapConstRefIfLi4EEEPKc"]
    pub fn msdfgen_saveTiff2(bitmap: *const u8, filename: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Generates a conventional single-channel signed distance field."]
    #[link_name = "\u{1}__ZN7msdfgen11generateSDFERKNS_9BitmapRefIfLi1EEERKNS_5ShapeERKNS_10ProjectionEdRKNS_15GeneratorConfigE"]
    pub fn msdfgen_generateSDF(
        output: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        range: f64,
        config: *const msdfgen_GeneratorConfig,
    );
}
extern "C" {
    #[doc = " Generates a single-channel signed pseudo-distance field."]
    #[link_name = "\u{1}__ZN7msdfgen17generatePseudoSDFERKNS_9BitmapRefIfLi1EEERKNS_5ShapeERKNS_10ProjectionEdRKNS_15GeneratorConfigE"]
    pub fn msdfgen_generatePseudoSDF(
        output: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        range: f64,
        config: *const msdfgen_GeneratorConfig,
    );
}
extern "C" {
    #[doc = " Generates a multi-channel signed distance field. Edge colors must be assigned first! (See edgeColoringSimple)"]
    #[link_name = "\u{1}__ZN7msdfgen12generateMSDFERKNS_9BitmapRefIfLi3EEERKNS_5ShapeERKNS_10ProjectionEdRKNS_19MSDFGeneratorConfigE"]
    pub fn msdfgen_generateMSDF(
        output: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        range: f64,
        config: *const msdfgen_MSDFGeneratorConfig,
    );
}
extern "C" {
    #[doc = " Generates a multi-channel signed distance field with true distance in the alpha channel. Edge colors must be assigned first."]
    #[link_name = "\u{1}__ZN7msdfgen13generateMTSDFERKNS_9BitmapRefIfLi4EEERKNS_5ShapeERKNS_10ProjectionEdRKNS_19MSDFGeneratorConfigE"]
    pub fn msdfgen_generateMTSDF(
        output: *const u8,
        shape: *const msdfgen_Shape,
        projection: *const msdfgen_Projection,
        range: f64,
        config: *const msdfgen_MSDFGeneratorConfig,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen11generateSDFERKNS_9BitmapRefIfLi1EEERKNS_5ShapeEdRKNS_7Vector2ES9_b"]
    pub fn msdfgen_generateSDF1(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        overlapSupport: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen17generatePseudoSDFERKNS_9BitmapRefIfLi1EEERKNS_5ShapeEdRKNS_7Vector2ES9_b"]
    pub fn msdfgen_generatePseudoSDF1(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        overlapSupport: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen12generateMSDFERKNS_9BitmapRefIfLi3EEERKNS_5ShapeEdRKNS_7Vector2ES9_RKNS_21ErrorCorrectionConfigEb"]
    pub fn msdfgen_generateMSDF1(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        errorCorrectionConfig: *const msdfgen_ErrorCorrectionConfig,
        overlapSupport: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen13generateMTSDFERKNS_9BitmapRefIfLi4EEERKNS_5ShapeEdRKNS_7Vector2ES9_RKNS_21ErrorCorrectionConfigEb"]
    pub fn msdfgen_generateMTSDF1(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        errorCorrectionConfig: *const msdfgen_ErrorCorrectionConfig,
        overlapSupport: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen18generateSDF_legacyERKNS_9BitmapRefIfLi1EEERKNS_5ShapeEdRKNS_7Vector2ES9_"]
    pub fn msdfgen_generateSDF_legacy(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen24generatePseudoSDF_legacyERKNS_9BitmapRefIfLi1EEERKNS_5ShapeEdRKNS_7Vector2ES9_"]
    pub fn msdfgen_generatePseudoSDF_legacy(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen19generateMSDF_legacyERKNS_9BitmapRefIfLi3EEERKNS_5ShapeEdRKNS_7Vector2ES9_NS_21ErrorCorrectionConfigE"]
    pub fn msdfgen_generateMSDF_legacy(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        errorCorrectionConfig: msdfgen_ErrorCorrectionConfig,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen20generateMTSDF_legacyERKNS_9BitmapRefIfLi4EEERKNS_5ShapeEdRKNS_7Vector2ES9_NS_21ErrorCorrectionConfigE"]
    pub fn msdfgen_generateMTSDF_legacy(
        output: *const u8,
        shape: *const msdfgen_Shape,
        range: f64,
        scale: *const msdfgen_Vector2,
        translate: *const msdfgen_Vector2,
        errorCorrectionConfig: msdfgen_ErrorCorrectionConfig,
    );
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen19Contour_constructorEv"]
    pub fn msdfgen_Contour_constructor() -> msdfgen_Contour;
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen18Contour_destructorERNS_7ContourE"]
    pub fn msdfgen_Contour_destructor(self_: *mut msdfgen_Contour);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen16Shape_destructorERNS_5ShapeE"]
    pub fn msdfgen_Shape_destructor(self_: *mut msdfgen_Shape);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen19Scanline_destructorERNS_8ScanlineE"]
    pub fn msdfgen_Scanline_destructor(self_: *mut msdfgen_Scanline);
}
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen21EdgeHolder_setSegmentERNS_10EdgeHolderERKNS_11EdgeSegmentE"]
    pub fn msdfgen_EdgeHolder_setSegment(
        self_: *mut msdfgen_EdgeHolder,
        segment: *const msdfgen_EdgeSegment,
    );
}
pub const msdfgen_SegmentKind_LINEAR: msdfgen_SegmentKind = 0;
pub const msdfgen_SegmentKind_QUADRATIC: msdfgen_SegmentKind = 1;
pub const msdfgen_SegmentKind_CUBIC: msdfgen_SegmentKind = 2;
pub type msdfgen_SegmentKind = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}__ZN7msdfgen19EdgeSegment_getKindERKNS_11EdgeSegmentE"]
    pub fn msdfgen_EdgeSegment_getKind(self_: *const msdfgen_EdgeSegment) -> msdfgen_SegmentKind;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    fn test_field__base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_base)
            )
        );
    }
    test_field__base();
    fn test_field__size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_size)
            )
        );
    }
    test_field__size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    fn test_field__p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_p)
            )
        );
    }
    test_field__p();
    fn test_field__r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_r)
            )
        );
    }
    test_field__r();
    fn test_field__w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_w)
            )
        );
    }
    test_field__w();
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_file)
            )
        );
    }
    test_field__file();
    fn test_field__bf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_bf)
            )
        );
    }
    test_field__bf();
    fn test_field__lbfsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lbfsize)
            )
        );
    }
    test_field__lbfsize();
    fn test_field__cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_cookie)
            )
        );
    }
    test_field__cookie();
    fn test_field__close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_close)
            )
        );
    }
    test_field__close();
    fn test_field__read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_read)
            )
        );
    }
    test_field__read();
    fn test_field__seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_seek)
            )
        );
    }
    test_field__seek();
    fn test_field__write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_write)
            )
        );
    }
    test_field__write();
    fn test_field__ub() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ub)
            )
        );
    }
    test_field__ub();
    fn test_field__extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_extra)
            )
        );
    }
    test_field__extra();
    fn test_field__ur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ur)
            )
        );
    }
    test_field__ur();
    fn test_field__ubuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ubuf)
            )
        );
    }
    test_field__ubuf();
    fn test_field__nbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
            },
            119usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_nbuf)
            )
        );
    }
    test_field__nbuf();
    fn test_field__lb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lb)
            )
        );
    }
    test_field__lb();
    fn test_field__blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_blksize)
            )
        );
    }
    test_field__blksize();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
}
